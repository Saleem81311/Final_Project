/*****************************************************************************************************************
 * Authors: Figurski, Griggs-Taylor, Hoffmann
 * Date: 12/9/2021
 * Description: Program to accept input from a speed entered into the keypad and make the motor run at that
 * speed. Incorporated emergency stop as well.
 *****************************************************************************************************************/
#include "msp.h"
#include <stdio.h>
#include <stdlib.h>

int Read_Keypad (void);                         //function declarations
int arrayToDuty(int array[]);
void TimerA0_PWM(int duty);
void Timer_Init(void);
void Pin_Init(void);
void Set_Motor_Speed (void);
void Door_Control (int pos);
void TimerA2_PWM(int position);

void main(void)
{
     WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD; // stop watchdog timer

     Pin_Init();                                //initialize the pins and the timer
     Timer_Init();

     NVIC_EnableIRQ(PORT6_IRQn);  // set up to run code
     __enable_interrupts();


     //printf("Enter value from 0 to 9 for Speed.\n");

     while (1){
         //Set_Motor_Speed();
         Door_Control(1);
         __delay_cycles(3000000);
         Door_Control(0);
         __delay_cycles(3000000);
     }
}

int Read_Keypad (void){ //detects and reads key pressed
    int i, j, key = 0;
    for (i = 4; i < 7; i++){
        P4->DIR |= (0x01 << i);
        P4->OUT &= ~(0x01 << i);
        __delay_cycles(5000);
        for (j = 0; j < 4; j++){
            if (!(P4->IN & BIT(j))){
                while (!(P4->IN & BIT(j)));
                if (j == 0)
                    key = i - 3;
                else if (j == 1)
                    key = i;
                else if (j == 2)
                    key = i + 3;
                else
                    key = i + 6;
            }
        }
        P4->DIR &= ~(0x7F);
        P4->OUT |= 0x7F;
    }
    return key;
}

void Timer_Init(void){              //Initializes the timer
    TIMER_A0-> CTL = 0b1001010100;                      //Count up using smclk, clears TAOR register, /2
    TIMER_A0-> CCR[0] = 37500 - 1;                      //TimerA will count up to 37500-1
    TIMER_A0-> CCR[4] = 0;                              //motor off to start
    TIMER_A0-> CCTL[4] = 0b11100000;                    //reset/set mode
}

void Pin_Init(void){
    P2-> SEL0 &= ~(BIT0|BIT1);
    P2-> SEL1 &= ~(BIT0|BIT1);
    P2-> DIR |= (BIT0|BIT1);                                 //sets LEDs for GPIO as an output
    P2-> OUT &= ~(BIT0|BIT1);

    P2-> SEL0 |= BIT7;
    P2-> SEL1 &=~ BIT7;
    P2-> DIR |= BIT7;                                 //sets pin 2.7 as timerA0.4
    P2-> OUT &= ~BIT7;                                //off to start

    P4-> SEL0 &= ~(0x7F);                               //initialize all pins to GPIO
    P4-> SEL1 &= ~(0x7F);                               //as inputs with pull up resistors
    P4-> DIR &= ~(0x7F);
    P4-> REN |= 0x7F;
    P4-> OUT |= 0x7F;

    P6-> SEL0 &=~ BIT0;
    P6-> SEL1 &=~ BIT0;
    P6-> DIR &=~ BIT0;
    P6-> REN |= BIT0; //pullup resistor
    P6-> OUT |= BIT0;
    P6-> IE |= BIT0; //enable interupts for P6.4
    P6-> IES |= BIT0; // Set pin to interrupt to trigger when it goes high->low
    P6-> IFG &=~ BIT0; //clear P1 interrupt flags

    P6-> SEL0 |= (BIT6|BIT7);
    P6-> SEL1 &=~ (BIT6|BIT7);
    P6-> DIR |= (BIT6|BIT7);                                 //sets pin 6.6 and 6.7 as timerA2
    P6-> OUT &= ~(BIT6|BIT7);                                //off to start

    P5-> SEL0 |= BIT7;
    P5-> SEL1 &=~ BIT7;
    P5-> DIR |= BIT7;                                 //sets pin 5.6 as timerA2
    P5-> OUT &= ~BIT7;                                //off to start
}

void TimerA0_PWM(int duty){               //runs timer given the specified duty cycle

    TIMER_A0-> CTL = 0b1001010100;                      //Count up using smclk, clears TAOR register, /2
    TIMER_A0-> CCR[0] = 37500 - 1;                      //TimerA will count up to 37500-1
    if (duty == 0)
        TIMER_A0-> CCR[4] = 0;
    else
        TIMER_A0-> CCR[4] = (37500 * duty / 100) - 1;   //Sets the duty cycle.
    TIMER_A0-> CCTL[4] = 0b11100000;                    //reset/set mode
}

void Set_Motor_Speed (void){
    int num = 0, speed = 0;
    num = Read_Keypad();                   //get key press from the keypad
    if ((num != 10) && (num != 12) && (num > 0) && (num < 13)){
        if (num == 11)
            num = 0;
        speed = num * 10;
        printf("Speed Entered: %d\n", num);    //confirms speed
        TimerA0_PWM(speed);                        //changes timer to new PWM
    }
}

void PORT6_IRQHandler(void){
    if(P6->IFG & BIT4){
        __delay_cycles(15000);
        if (!(P6->IN & BIT0)){
            printf("Emergency Stop!\n");
            TimerA0_PWM(0);
            P6->IFG  &= ~BIT0;  //clear the flag
        }
    }
}

void Door_Control (int pos){
    if (pos == 1){
        P2->OUT &= ~BIT0;
        P2->OUT |= BIT1;
        TimerA2_PWM(1);
    }
    if (pos == 0){
        P2->OUT &= ~BIT1;
        P2->OUT |= BIT0;
        TimerA2_PWM(0);
    }
}

void TimerA2_PWM(int position){               //runs timer given the specified duty cycle
    TIMER_A2-> CTL = 0b1000010100;                      //Count up using smclk, clears TAOR register, /1
    TIMER_A2-> CCR[0] = 63000 - 1;                      //TimerA will count up to 63000-1
    if (position == 0){
        TIMER_A2-> CCR[4] = 2700 - 1;
        TIMER_A2-> CCR[3] = 2700 - 1;
        TIMER_A2-> CCR[2] = 6300 - 1;

    }
    if (position == 1){
        TIMER_A2-> CCR[4] = 6300 - 1;
        TIMER_A2-> CCR[3] = 6300 - 1;
        TIMER_A2-> CCR[2] = 2700 - 1;
    }
    TIMER_A2-> CCTL[4] = 0b11100000;
    TIMER_A2-> CCTL[3] = 0b11100000;                    //reset/set mode
    TIMER_A2-> CCTL[2] = 0b11100000;
}